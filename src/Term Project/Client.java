package chatting_program;

import java.io.BufferedReader;
import java.io.DataOutputStream;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.net.Socket;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.sql.Date;
import java.text.SimpleDateFormat;
import java.util.Base64;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public class Client implements Runnable
{

	BufferedReader reader1, reader2;
	PrintWriter writer;
	Socket socket;
	Thread t1, t2;
	volatile String in = "";
	volatile String out = "";
	String host = "";
	static int PORT = 5678;
	ObjectInputStream inO = null;
	InputStream is = null;
	volatile boolean start1 = true;
	volatile boolean flag1 = false;
	PublicKey pub_RSA = null;
	SecretKey sKey = null;
	ObjectOutputStream outO = null;
	OutputStream os = null;
	byte[] encrypted_AESkey = null;
	static String iv = "0987654321654321";
	
	
	
	public static void main(String[] args)
	{
		new Client();
		
	}
	
	
	public Client()
	{
		try {
			
			//Thread for read
			t1 = new Thread(this);
			
			//Thread for write
			t2 = new Thread(this);
			
			
			socket = new Socket(host, PORT);
			
			t1.start();
			t2.start();

		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	

	public void run(){
		try{
			if (Thread.currentThread() == t2){
				/*
				 * Writing Thread
				 */
				while(true) {
					if(flag1 == true) {
						
						os = socket.getOutputStream();
						outO = new ObjectOutputStream(os);
						outO.writeObject(encrypted_AESkey);
						outO.flush();
					
						
						break;
					} 
				}
				
				while (!in.equals("exit")){
					//Writing chat
					
					reader1 = new BufferedReader(new InputStreamReader(System.in));
					writer = new PrintWriter(socket.getOutputStream(), true);
					
					//Add time stamp to entered message
					Long timeStamp = System.currentTimeMillis(); 
			        SimpleDateFormat sdf=new SimpleDateFormat("[yyyy-MM-dd HH:mm:ss]");
			        String sd = sdf.format(new Date(Long.parseLong(String.valueOf(timeStamp)))); 
			        
					in = reader1.readLine();
					String send = "\"" + in +"\"" + " " + sd;
					
					//Encrypt with AES256
					String send_encrypt = Encrypt_AES(send, sKey);
					
					writer.println(send_encrypt);

				}
				
			} else {
				/*
				 * Reading Thread
				 */
				
				while(true) {
					if(pub_RSA == null) {
						
						//Get Server's public key
						is = socket.getInputStream();
						inO = new ObjectInputStream(is);
						pub_RSA = (PublicKey)inO.readObject();
						
						//Print RSA Public Key
						System.out.println("[RSA PublicKey info Received from Server]");
						System.out.println(pub_RSA + "\n");
						
					} else {
						
						//Encrypt the AES key with Server's public key
						sKey = generate_AES_key();
						
						encrypted_AESkey = Encrypt_RSA(sKey, pub_RSA);
						
						//byte배열을 원래 대칭키로 바꾸는법
						//SecretKey originalKey = new SecretKeySpec(sKey_byte, 0, sKey_byte.length, "AES");
						
						flag1 = true;
						
						//Print AES SecretKey generate by Client
						System.out.println("[AES SecretKey info generated by Client]");
						System.out.println(sKey + "\n");
						
						break;
					}
				}
				
				
				while (!out.equals("exit")) {
					//Reading chat
					
					reader2 = new BufferedReader(new InputStreamReader(socket.getInputStream()));
					out = reader2.readLine();
					
					String decrypted_out = Decrypt_AES(out, sKey);
					
					System.out.println("[From Server] " + decrypted_out);
					System.out.println("[Encrypted Message] \"" + out + "\" + \n");
				}
			}
			
			writer.close();
			reader1.close();
			reader2.close();
			socket.close();
			
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	
	
	public static byte[] Encrypt_RSA(SecretKey plaintext, PublicKey publicKey) 
	{
		byte[] encryptedSecret = null;
		
		try {
			
			Cipher cipher = Cipher.getInstance("RSA");
		
			cipher.init(Cipher.ENCRYPT_MODE, publicKey);
			encryptedSecret = cipher.doFinal(plaintext.getEncoded());
			
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		return encryptedSecret;
	}
	
	
	public static SecretKey generate_AES_key() {
		
		System.out.println("[Creating AES 256 Secret Key...]");
		
		SecretKey key = null;
		
		try {
			
		    KeyGenerator gen = KeyGenerator.getInstance("AES");
		    gen.init(256);
		    
		    key = gen.generateKey();
		    
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		return key; 
	}
	

		
	
	public static String Encrypt_AES(String plaintext, SecretKey key)
	{
		String result = null;
		
		try {
		    
			Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding");
		    c.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(iv.getBytes()));
		 
		    byte[] encrypted = c.doFinal(plaintext.getBytes("UTF-8"));
		    result = new String(Base64.getEncoder().encode(encrypted));
		 
		    
		} catch (Exception e) {
			e.printStackTrace();
		}
		return result;
	}
	
	
	public static String Decrypt_AES(String ciphertext, SecretKey key)
	{
		String result = null;
		
		try {
		    
		    Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding");
		    c.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv.getBytes("UTF-8")));
		    
		    byte[] decrypted = Base64.getDecoder().decode(ciphertext.getBytes("UTF-8"));
		    result = new String(c.doFinal(decrypted), "UTF-8");
		 
		    
		} catch (Exception e) {
			e.printStackTrace();
		}
		return result;
	}
}